package graphite.textual;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EDataType;
import org.eclipse.emf.ecore.EEnum;
import org.eclipse.emf.ecore.EEnumLiteral;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.epsilon.eol.types.EolSequence;
import org.eclipse.epsilon.eol.types.EolTuple;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.xbase.lib.ExclusiveRange;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xtext.wizard.Ecore2XtextConfiguration;
import org.eclipse.xtext.xtext.wizard.WizardConfiguration;
import org.eclipse.xtext.xtext.wizard.ecore2xtext.Ecore2XtextExtensions;
import org.eclipse.xtext.xtext.wizard.ecore2xtext.Ecore2XtextGrammarCreator;
import org.eclipse.xtext.xtext.wizard.ecore2xtext.UniqueNameUtil;

@SuppressWarnings("all")
public class CustomEcore2XtextGrammarCreator extends Ecore2XtextGrammarCreator {
  public <T extends EClassifier> List<T> butAll(final Iterable<T> classes, final List<EClassifier> it) {
    final List<T> retVal = IterableExtensions.<T>toList(classes);
    retVal.removeAll(it);
    return retVal;
  }

  public CharSequence grammar(final WizardConfiguration config, final Map<EClass, EolSequence> grammarData, final int numberOfAlternativeRules, final String metamodelUri, final EPackage packageImpl) {
    CharSequence _xblockexpression = null;
    {
      final Ecore2XtextConfiguration it = config.getEcore2Xtext();
      UniqueNameUtil.clearUniqueNames(it.getDefaultEPackageInfo());
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("// automatically generated by Xtext");
      _builder.newLine();
      _builder.append("grammar ");
      String _name = config.getLanguage().getName();
      _builder.append(_name);
      _builder.append(" with org.eclipse.xtext.common.Terminals");
      _builder.newLineIfNotEmpty();
      _builder.newLine();
      {
        int _size = packageImpl.getESubpackages().size();
        boolean _greaterThan = (_size > 0);
        if (_greaterThan) {
          _builder.append("import \"");
          String _nsURI = EcorePackage.eINSTANCE.getNsURI();
          _builder.append(_nsURI);
          _builder.append("\" as ecore");
          _builder.newLineIfNotEmpty();
          _builder.append("import \"");
          _builder.append(metamodelUri);
          _builder.append("\" as ");
          String _nsURI_1 = packageImpl.getNsURI();
          _builder.append(_nsURI_1);
          _builder.newLineIfNotEmpty();
          {
            EList<EPackage> _eSubpackages = packageImpl.getESubpackages();
            for(final EPackage it_1 : _eSubpackages) {
              _builder.append("import \"");
              _builder.append(metamodelUri);
              _builder.append("#//");
              String _nsURI_2 = it_1.getNsURI();
              _builder.append(_nsURI_2);
              _builder.append("\" as ");
              String _nsURI_3 = it_1.getNsURI();
              _builder.append(_nsURI_3);
              _builder.newLineIfNotEmpty();
            }
          }
        } else {
          {
            Collection<EPackage> _allReferencedEPackages = Ecore2XtextExtensions.allReferencedEPackages(it);
            for(final EPackage it_2 : _allReferencedEPackages) {
              _builder.append("import \"");
              String _nsURI_4 = it_2.getNsURI();
              _builder.append(_nsURI_4);
              _builder.append("\" ");
              {
                if (((UniqueNameUtil.uniqueName(it_2) != null) && (!Objects.equals(UniqueNameUtil.uniqueName(it_2), "")))) {
                  _builder.append("as ");
                  String _uniqueName = UniqueNameUtil.uniqueName(it_2);
                  _builder.append(_uniqueName);
                }
              }
              _builder.newLineIfNotEmpty();
            }
          }
        }
      }
      _builder.newLine();
      {
        if ((numberOfAlternativeRules > 0)) {
          String _name_1 = it.getRootElementClass().getName();
          _builder.append(_name_1);
          _builder.append(" returns ");
          {
            int _size_1 = packageImpl.getESubpackages().size();
            boolean _greaterThan_1 = (_size_1 > 0);
            if (_greaterThan_1) {
              String _name_2 = it.getRootElementClass().getEPackage().getName();
              _builder.append(_name_2);
              _builder.append("::");
            }
          }
          String _name_3 = it.getRootElementClass().getName();
          _builder.append(_name_3);
          _builder.append(":");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          final List<Map.Entry<EClass, EolSequence>> entries = IterableExtensions.<Map.Entry<EClass, EolSequence>>toList(grammarData.entrySet());
          _builder.newLineIfNotEmpty();
          {
            int _size_2 = entries.size();
            ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _size_2, true);
            for(final Integer itIndex : _doubleDotLessThan) {
              _builder.append("\t");
              final Map.Entry<EClass, EolSequence> it_3 = entries.get((itIndex).intValue());
              _builder.newLineIfNotEmpty();
              _builder.append("\t");
              final EolSequence values = it_3.getValue();
              _builder.newLineIfNotEmpty();
              {
                int _size_3 = values.size();
                ExclusiveRange _doubleDotLessThan_1 = new ExclusiveRange(0, _size_3, true);
                for(final Integer i : _doubleDotLessThan_1) {
                  _builder.append("\t");
                  Object _get = values.get((i).intValue());
                  final EolTuple eolTuple = ((EolTuple) _get);
                  _builder.newLineIfNotEmpty();
                  _builder.append("\t");
                  Object _get_1 = eolTuple.get("entryRule");
                  final String entryRule = ((String) _get_1);
                  _builder.newLineIfNotEmpty();
                  {
                    if ((((i).intValue() == (values.size() - 1)) && ((itIndex).intValue() == (entries.size() - 1)))) {
                      _builder.append("\t");
                      _builder.append(entryRule, "\t");
                      _builder.append(";");
                      _builder.newLineIfNotEmpty();
                    } else {
                      _builder.append("\t");
                      _builder.append(entryRule, "\t");
                      _builder.append(" |");
                      _builder.newLineIfNotEmpty();
                    }
                  }
                }
              }
            }
          }
        }
      }
      {
        Set<Map.Entry<EClass, EolSequence>> _entrySet = grammarData.entrySet();
        for(final Map.Entry<EClass, EolSequence> it_4 : _entrySet) {
          {
            EolSequence _value = it_4.getValue();
            for(final Object itt : _value) {
              final EolTuple eolTuple_1 = ((EolTuple) itt);
              _builder.newLineIfNotEmpty();
              Object _get_2 = eolTuple_1.get("entryRule");
              final String entryRule_1 = ((String) _get_2);
              _builder.newLineIfNotEmpty();
              Object _get_3 = eolTuple_1.get("derivedAttributeName");
              final String derivedAttributeName = ((String) _get_3);
              _builder.newLineIfNotEmpty();
              _builder.newLine();
              CharSequence _customRules = this.customRules(it_4.getKey(), derivedAttributeName, entryRule_1);
              _builder.append(_customRules);
              _builder.newLineIfNotEmpty();
            }
          }
        }
      }
      {
        Collection<EClass> _allDispatcherRuleClasses = CustomEcore2XtextExtensions.allDispatcherRuleClasses(it, grammarData);
        Set<EClass> _keySet = grammarData.keySet();
        ArrayList<EClassifier> _arrayList = new ArrayList<EClassifier>(_keySet);
        List<EClass> _butAll = this.<EClass>butAll(_allDispatcherRuleClasses, _arrayList);
        for(final EClass it_5 : _butAll) {
          _builder.newLine();
          CharSequence _subClassDispatcherRule = this.subClassDispatcherRule(it_5);
          _builder.append(_subClassDispatcherRule);
          _builder.newLineIfNotEmpty();
        }
      }
      {
        Iterable<EClassifier> _allConcreteRuleClassifiers = CustomEcore2XtextExtensions.allConcreteRuleClassifiers(it, grammarData);
        Set<EClass> _keySet_1 = grammarData.keySet();
        ArrayList<EClassifier> _arrayList_1 = new ArrayList<EClassifier>(_keySet_1);
        List<EClassifier> _butAll_1 = this.<EClassifier>butAll(_allConcreteRuleClassifiers, _arrayList_1);
        for(final EClassifier it_6 : _butAll_1) {
          _builder.newLine();
          CharSequence _rule = this.rule(it_6);
          _builder.append(_rule);
          _builder.newLineIfNotEmpty();
        }
      }
      _xblockexpression = _builder;
    }
    return _xblockexpression;
  }

  public CharSequence customRules(final EClassifier it, final String derivedElementName, final String entryRule) {
    CharSequence _xifexpression = null;
    if (((it != null) && Ecore2XtextExtensions.needsConcreteRule(it))) {
      _xifexpression = this.customRule(it, derivedElementName, entryRule);
    }
    return _xifexpression;
  }

  public CharSequence customRule(final EClassifier it, final String derivedElementName, final String entryRule) {
    CharSequence _switchResult = null;
    boolean _matched = false;
    if (it instanceof EClass) {
      _matched=true;
      StringConcatenation _builder = new StringConcatenation();
      String _quoteIfNeccesary = Ecore2XtextExtensions.quoteIfNeccesary(entryRule);
      _builder.append(_quoteIfNeccesary);
      _builder.append(" returns ");
      String _fqn = Ecore2XtextExtensions.fqn(it);
      _builder.append(_fqn);
      _builder.append(":");
      _builder.newLineIfNotEmpty();
      {
        boolean _onlyOptionalFeatures = Ecore2XtextExtensions.onlyOptionalFeatures(((EClass)it));
        if (_onlyOptionalFeatures) {
          _builder.append("\t");
          _builder.append("{");
          String _fqn_1 = Ecore2XtextExtensions.fqn(it);
          _builder.append(_fqn_1, "\t");
          _builder.append("}");
          _builder.newLineIfNotEmpty();
        }
      }
      {
        Iterable<EStructuralFeature> _prefixFeatures = Ecore2XtextExtensions.prefixFeatures(((EClass)it));
        for(final EStructuralFeature strF : _prefixFeatures) {
          _builder.append("\t");
          CharSequence _assigment = this.assigment(strF);
          _builder.append(_assigment, "\t");
          _builder.newLineIfNotEmpty();
        }
      }
      _builder.append("\t");
      _builder.append("\'{\'");
      _builder.newLine();
      {
        Iterable<EReference> _allContainmentReferences = Ecore2XtextExtensions.allContainmentReferences(((EClass)it));
        for(final EReference conti : _allContainmentReferences) {
          {
            String _name = conti.getName();
            boolean _equals = Objects.equals(_name, derivedElementName);
            if (_equals) {
              _builder.append("\t\t");
              CharSequence _assigment_1 = this.assigment(conti);
              _builder.append(_assigment_1, "\t\t");
              _builder.newLineIfNotEmpty();
            }
          }
        }
      }
      _builder.append("\t");
      _builder.append("\'}\';");
      _builder.newLine();
      _switchResult = _builder;
    }
    if (!_matched) {
      if (it instanceof EEnum) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("enum ");
        String _quoteIfNeccesary = Ecore2XtextExtensions.quoteIfNeccesary(((EEnum)it).getName());
        _builder.append(_quoteIfNeccesary);
        _builder.append(" returns ");
        String _fqn = Ecore2XtextExtensions.fqn(it);
        _builder.append(_fqn);
        _builder.append(":");
        _builder.newLineIfNotEmpty();
        _builder.append("\t\t\t\t");
        final Function1<EEnumLiteral, String> _function = (EEnumLiteral it_1) -> {
          String _quoteIfNeccesary_1 = Ecore2XtextExtensions.quoteIfNeccesary(it_1.getName());
          String _plus = (_quoteIfNeccesary_1 + " = \'");
          String _name = it_1.getName();
          String _plus_1 = (_plus + _name);
          return (_plus_1 + "\'");
        };
        String _join = IterableExtensions.join(ListExtensions.<EEnumLiteral, String>map(((EEnum)it).getELiterals(), _function), " | ");
        _builder.append(_join, "\t\t\t\t");
        _builder.append(";");
        _switchResult = _builder;
      }
    }
    if (!_matched) {
      if (it instanceof EDataType) {
        _matched=true;
        CharSequence _xifexpression = null;
        boolean _isSerializable = ((EDataType)it).isSerializable();
        if (_isSerializable) {
          StringConcatenation _builder = new StringConcatenation();
          String _uniqueName = UniqueNameUtil.uniqueName(it);
          _builder.append(_uniqueName);
          _builder.append(" returns ");
          String _fqn = Ecore2XtextExtensions.fqn(it);
          _builder.append(_fqn);
          _builder.append(":");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          String _dataTypeRuleBody = Ecore2XtextExtensions.dataTypeRuleBody(((EDataType)it));
          _builder.append(_dataTypeRuleBody, "\t");
          _builder.append(";");
          _builder.newLineIfNotEmpty();
          _xifexpression = _builder;
        }
        _switchResult = _xifexpression;
      }
    }
    if (!_matched) {
      throw new IllegalStateException(("No rule template for " + it));
    }
    return _switchResult;
  }
}
