package graphite.textual

import java.util.List
import java.util.Map
import java.util.ArrayList

import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EClassifier
import org.eclipse.emf.ecore.EDataType
import org.eclipse.emf.ecore.EEnum
import org.eclipse.epsilon.eol.types.EolSequence
import org.eclipse.epsilon.eol.types.EolTuple
import org.eclipse.xtext.xtext.wizard.Ecore2XtextConfiguration
import org.eclipse.xtext.xtext.wizard.WizardConfiguration
import org.eclipse.xtext.xtext.wizard.ecore2xtext.Ecore2XtextGrammarCreator

import static extension org.eclipse.xtext.xtext.wizard.ecore2xtext.Ecore2XtextExtensions.*
import static extension org.eclipse.xtext.xtext.wizard.ecore2xtext.UniqueNameUtil.*
import org.eclipse.emf.ecore.EcorePackage
import org.eclipse.emf.ecore.EPackage

class CustomEcore2XtextGrammarCreator extends Ecore2XtextGrammarCreator {
		
	def <T extends EClassifier> List<T> butAll(Iterable<T> classes, List<EClassifier> it) {
		val retVal = classes.toList
		retVal.removeAll(it)
		return retVal
	}
	
	def grammar(WizardConfiguration config, Map<EClass, EolSequence> grammarData, int numberOfAlternativeRules, String metamodelUri, EPackage packageImpl) {
		val it = config.ecore2Xtext
		defaultEPackageInfo.clearUniqueNames
		'''
		// automatically generated by Xtext
		grammar «config.language.name» with org.eclipse.xtext.common.Terminals
		
		«IF packageImpl.getESubpackages().size() > 0»
			import "«EcorePackage.eINSTANCE.getNsURI()»" as ecore
			import "«metamodelUri»" as «packageImpl.getNsURI()»
			«FOR it: packageImpl.getESubpackages()»		
				import "«metamodelUri»#//«it.getNsURI()»" as «it.getNsURI()»
			«ENDFOR»
		«ELSE»
			«FOR it: allReferencedEPackages»
			import "«nsURI»" «IF uniqueName !== null && uniqueName != ""»as «uniqueName»«ENDIF»
			«ENDFOR»
		«ENDIF»
		
		«IF numberOfAlternativeRules > 0»
			«rootElementClass.getName()» returns «IF packageImpl.getESubpackages().size() > 0»«rootElementClass.getEPackage().getName()»::«ENDIF»«rootElementClass.getName()»:
				«val entries = grammarData.entrySet().toList»
				«FOR itIndex : 0 ..< entries.size»
					«val it = entries.get(itIndex)»
					«val values = it.getValue()»
					«FOR i : 0 ..< values.size»
						«val eolTuple = values.get(i) as EolTuple»
						«val entryRule = eolTuple.get("entryRule") as String»
						«IF i == values.size - 1 && itIndex == entries.size - 1»
							«entryRule»;
						«ELSE»
							«entryRule» |
						«ENDIF»
					«ENDFOR»
				«ENDFOR»
		«ENDIF»
		«FOR it: grammarData.entrySet()»
			«FOR itt: it.getValue()»
				«val eolTuple = itt as EolTuple»
				«val entryRule = eolTuple.get("entryRule") as String»
				«val derivedAttributeName = eolTuple.get("derivedAttributeName") as String»
				
				«it.getKey().customRules(derivedAttributeName, entryRule)»
			«ENDFOR»
		«ENDFOR»
		«FOR it:CustomEcore2XtextExtensions.allDispatcherRuleClasses(it, grammarData).butAll(new ArrayList<EClassifier>(grammarData.keySet()))»

			«subClassDispatcherRule»
		«ENDFOR»
		«FOR it:CustomEcore2XtextExtensions.allConcreteRuleClassifiers(it, grammarData).butAll(new ArrayList<EClassifier>(grammarData.keySet()))»

			«rule(it)»
		«ENDFOR»
		'''
	}
	
	def customRules(EClassifier it, String derivedElementName, String entryRule) {
		if (it !== null && it.needsConcreteRule) {
			customRule(it, derivedElementName, entryRule)
		}
	}
	
	def customRule(EClassifier it, String derivedElementName, String entryRule) {
		switch(it) {
			EClass :
				'''
				«entryRule.quoteIfNeccesary» returns «fqn»:
					«IF (it.onlyOptionalFeatures)»
						{«fqn»}
					«ENDIF»
					«FOR strF: it.prefixFeatures»
					«strF.assigment»
					«ENDFOR»
					'{'
						«FOR conti: it.allContainmentReferences»
							«IF conti.name == derivedElementName»
								«conti.assigment»
							«ENDIF»
						«ENDFOR»
					'}';
				'''
			EEnum:
				'''enum «name.quoteIfNeccesary» returns «fqn»:
				«it.ELiterals.map([name.quoteIfNeccesary+" = '"+name+"'"]).join(' | ')»;'''
			EDataType:
				if (it.serializable) {
				'''
				«uniqueName» returns «fqn»:
					«it.dataTypeRuleBody»;
				'''
				}
			
			default:	
				throw new IllegalStateException("No rule template for "+it)
		}
	}
	
}